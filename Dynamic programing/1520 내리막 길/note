- dp에서 실제로 그 값이 0이 될 수 있는 경우, 초기화를 -1같은 초기값이 아니라면 가질 수 없는 값으로 해줘야 함
- 그렇게 안 하면 아래와 같은 문제 발생


주요한 시간 누수(비효율) 원인은 DP의 캐싱 방식에 있습니다. 구체적으로:

DP의 초기값 문제:

코드에서는 dp[y][x]가 0이 아니면 “계산되었다”고 판단하고 바로 반환합니다.

그러나 실제로 어떤 좌표에서 올바른 답이 0일 수 있습니다. 이 경우 dp[y][x]는 0으로 남게 되므로 “계산되지 않은 상태”와 “0으로 계산된 상태”를 구분하지 못합니다.

결과적으로 해당 셀에 대해 올바른 답이 0임에도 불구하고 매번 재귀 호출을 수행하게 되어, 중복 계산이 발생하고 이로 인해 시간 초과(TLE)의 원인이 될 수 있습니다.

중복 계산으로 인한 오버헤드:

만약 어떤 경로의 경우 dp 값이 0으로 계산된다면, 이후 같은 상태로 들어올 때마다 캐싱이 되지 않아 매번 dfs 호출이 이루어집니다.

500×500 격자의 경우, 최악의 시나리오에서는 상당히 많은 중복 연산이 발생할 수 있습니다.

해결 방법:
DP 배열을 -1 등으로 초기화해서 아직 계산되지 않은 상태와 0으로 계산된 상태를 구분해야 합니다. 예를 들어, dp[][]를 전역 변수 선언 시 0 대신 -1로 초기화(또는 memset과 함께 별도의 초기화 루프 사용)하고, 재귀 호출에서는 dp[y][x]가 -1이 아닐 경우 이미 계산된 것으로 판단하면 중복 계산을 피할 수 있습니다.

이러한 문제 때문에 백준의 테스트 케이스에서 시간 초과가 발생할 수 있습니다.
